/// <reference path="../typings/index.d.ts" />
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jitsuyo_1 = __importDefault(require("@tmware/jitsuyo"));
const variable_parser_1 = __importDefault(require("@tmware/variable-parser"));
const axios_1 = __importDefault(require("axios"));
const defaultStatuses = [
    { type: 'PLAYING', name: 'with {users} users' },
    { type: 'LISTENING', name: '{users} users' },
    { type: 'WATCHING', name: 'over {users} users' },
    { type: 'PLAYING', name: 'in {guilds} servers' },
    { type: 'WATCHING', name: '{guilds} servers' }
];
class StatusUpdater {
    /**
     * A status updater that can pull from the internet
     * @param {DiscordClient} client discord.js (extending) client
     * @param {Array<ActivityOptions> | String} statuses Either an array of ActivityOptions or a url to download such an array from.
     * @example const StatusUpdater = new StatusUpdater(client,
     * [
     *   { type: 'PLAYING', name: 'with {users} users'},
     *   { type: 'WATCHING', name: '{guilds} guilds'},
     *   ...
     * ])
     *
     * @example const StatusUpdater = new StatusUpdater(client, 'https://example.com/statuses.json')
     */
    constructor(client, statuses) {
        this.client = client;
        this.parser = new variable_parser_1.default();
        this._statuses = [];
        this.timer = false;
        this.isReady = false;
        if (statuses) {
            if (typeof statuses === 'string') {
                if (!jitsuyo_1.default.validators.isUrl(statuses)) {
                    throw new Error('Invalid statuses URL');
                }
                this.statusUrl = statuses;
            }
            else if (Array.isArray(statuses)) {
                this._statuses = statuses;
            }
            else {
                throw new Error('Invalid status options.');
            }
        }
        this._init();
    }
    async _init() {
        this._getStatuses().then(() => {
            this.isReady = true;
        });
    }
    /**
     * Try to download the latest ActivityOptions data.
     */
    async _getStatuses() {
        if (this.statusUrl) {
            this._statuses = (await axios_1.default.get(this.statusUrl)).data;
            return this._statuses;
        }
        else {
            return this._statuses || defaultStatuses;
        }
    }
    /**
     * Start automatically switching the client user's status
     * @param {Number} delay time between status updates in milliseconds
     */
    start(delay) {
        if (this.timer !== false) {
            throw new Error('automatic status updates are already enabled');
        }
        if (!this.statuses || this.statuses.length === 0) {
            throw new Error('must have at least one status to choose from');
        }
        this.timer = setInterval(() => {
            this.updateStatus();
        }, delay);
    }
    /**
     * Stop automatically switching the client user's status
     */
    stop() {
        if (this.timer === false) {
            throw new Error('automatic status updates are not enabled');
        }
        clearInterval(this.timer);
        this.timer = false;
    }
    /**
     * Re-fetch status details from online url
     * THIS WILL OVERRIDE CURRENT DATA BY DEFAULT
     * @param {Boolean} additive add new data to current via Array.push()
     * @returns {Promise<ActivityOptions[]>}
     */
    async refetchOnlineData(additive = false) {
        if (!this.statusUrl)
            throw new Error('no status url specified');
        else if (additive) {
            this._statuses.push(...((await axios_1.default.get(this.statusUrl)).data));
            return this.statuses;
        }
        else {
            this._statuses = (await axios_1.default.get(this.statusUrl)).data;
            return this.statuses;
        }
    }
    /**
     * Define a url for a remote file
     * Should be formatted as seen [here](https://gist.githubusercontent.com/TMUniversal/253bd3172c3002be3e15e1152dd31bd4/raw/3c9a2eeb9a79c0b999942e761b11838acb71d89f/exampleFile.json)
     * You should run refetchOnlineData() to make use of the new file
     * @example StatusUpdater
     * .setStatusFileUrl("https://gist.githubusercontent.com/TMUniversal/253bd3172c3002be3e15e1152dd31bd4/raw/3c9a2eeb9a79c0b999942e761b11838acb71d89f/exampleFile.json")
     * .refetchOnlineData()
     *
     * @param {String} url
     * @returns {StatusUpdater} returns `this` so you can chain .refetchOnlineData()
     */
    setStatusFileUrl(url) {
        if (!jitsuyo_1.default.validators.isUrl(url)) {
            throw new Error('Invalid statuses URL');
        }
        this.statusUrl = url;
        return this;
    }
    /**
     * Update the variable parser with the latest data from the client.
     */
    _updateParserData() {
        this.parser.updateData({
            users: this.client.users.cache.filter(u => !u.bot).size,
            guilds: this.client.guilds.cache.size,
            channels: this.client.channels.cache.size
        });
    }
    /**
     * Update the variables the StatusUpdater can parse.
     * @param {Object} data Data as an object
     * @see https://github.com/TMWare/variable-parser
     * @example
     * updateParserData({ someName: "something" })
     */
    updateParserData(data) {
        return this.parser.updateData(data);
    }
    /**
     * Add a status to the possible statuses
     * @param {ActivityOptions} status ActivityOptions
     */
    addStatus(status) {
        if (!this.isReady) {
            throw new Error('StatusUpdater is not ready.');
        }
        if (!status.name) {
            throw new Error('status must include at least a name');
        }
        if (!this._statuses.includes(status)) {
            this._statuses.push(status);
            return this.statuses;
        }
        else {
            throw new Error('Already included.');
        }
    }
    /**
     * An array of possible status messages (as ActivityOptions)
     * @type ActivityOptions[]
     */
    get statuses() {
        // If the status download isn't done yet, serve the default statuses instead.
        return this._statuses || defaultStatuses;
    }
    /**
     * Trigger a status update
     * @returns {Promise<Presence>}
     */
    async updateStatus(activity, shardId) {
        if (!this.client.user) {
            throw new Error('cannot update status of undefined client user');
        }
        if (!this.statuses || this.statuses.length === 0) {
            throw new Error('must have at least one status to choose from');
        }
        // get current information about guild amounts etc. from client, feed it to parser
        this._updateParserData();
        const $activity = activity
            ? this._getSafeActivity(activity)
            : this._chooseActivity();
        if (shardId)
            $activity.shardId = shardId;
        return this.client.user.setActivity($activity);
    }
    _chooseActivity() {
        return this._getSafeActivity(jitsuyo_1.default.arrayHelper.pickRandom(this.statuses));
    }
    _getSafeActivity(options) {
        return Object.assign(Object.assign({}, options), { 
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            type: options.type || 'PLAYING', name: options.name ? this.parser.parse(options.name) : 'a game' });
    }
}
exports.default = StatusUpdater;
module.exports = StatusUpdater;
